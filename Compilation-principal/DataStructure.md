# 选择
![picture 0](../images/90037e4233aae693245cd3b00bc5d64b49fbf739170b4ab5e976d1aac2fbb141.png)  

图片上的问题是关于数据结构逻辑分类的，选择题的正确答案是：C. 线性结构和非线性结构

这是因为在数据结构的逻辑分类中，最基本的分类是将数据结构分为线性结构和非线性结构。

线性结构的数据元素是一对一的关系，如链表、队列、栈和数组。
非线性结构的数据元素是多对多或一对多的关系，如图和树。

其他选项，如动态和静态结构，紧凑和非紧凑结构，是描述数据结构的其他方面，而不是它们的逻辑分类。

![picture 1](../images/72e9392cff899a99a230ff6716cbff35f0921673a1a53053cc49558133840b6b.png)  

根据您提供的图片，题目是关于链表操作的：

如果链表 L 的长度 LengthList(L) 是5，在执行删除操作 DelList(L, 2) 后，链表 `L` 的长度是多少？

这里 DelList(L, 2)`表示删除链表 L 中位置为2的元素。由于原来链表的长度是5，删除一个元素后，链表的长度应该是4。

因此，正确答案是：C. 4

![picture 2](../images/b8ee3d72f24d60fc09a8975524b99ccf72f2f0c1c74322385e14e6c96a290d0c.png)  

在数据结构中，与所使用的计算机无关的是：C. 逻辑结构

逻辑结构指的是数据元素之间的逻辑关系，如线性关系、层次关系或网状关系，这种关系与数据在计算机内部的存储方式无关，它不依赖于具体的计算机或存储介质。物理结构和存储结构则与具体的计算机系统和存储介质有关。

![picture 9](../images/d83fa99f18c9f9bfb7d45077bc95dfc150bf5da500c9898c5bd7b8a2887dbd5b.png)  

代码片段包含两个嵌套的 for 循环。这段代码的时间复杂度是由两个循环决定的。外循环运行 m 次，内循环对于外循环的每次迭代都运行 n 次。因此，内部代码 a[i][j]=i*j; 将执行 m*n 次。

所以，这段代码的时间复杂度是：C. O(m*n)

![picture 3](../images/92476df2fb23370976aec06452845ce05ea61ccbfcb8b790d78753a16ac985bd.png)  

这段C代码是两个嵌套的 for 循环。根据给出的代码，需要计算语句 T 的执行次数。

如果两个循环都是独立地从 1 到 `n` 迭代，那么内部的语句 `T` 将被执行 `n` 次对于外部循环的每一次迭代。由于外部循环也迭代 `n` 次，那么 `T` 会被执行 `n * n` 次，即 `n` 的平方次。

所以正确的时间复杂度是：A. \( O(n^2) \)

>如果是 j<=i：
>
>这是一个典型的示例，显示了一个循环内嵌套另一个循环。外循环对 i 从 1 迭代到 n，内循环在每次外循环的迭代中对 j 从 1 迭代到 i。所以，对于 i 的每个值，T 将执行 i 次。这就形成了以下的执行次数序列：
>
>当 i=1, T 执行 1 次；
>当 i=2, T 执行 2 次；
>当 i=3, T 执行 3 次；
>...
>当 i=n, T 执行 n 次。
>
>T 的总执行次数是 1 + 2 + 3 + ... + n，这是一个等差数列的和，其公式是 n(n+1)/2。

![picture 4](../images/b653b665e9fc7c4bd89b90c1fa39d222fb32c9b0d9fea3d7a6c2bd7c34f7049e.png)  

此段代码中，i 以3倍的速率增长，直到 i 大于或等于 n。每次循环，i 都乘以3，所以如果我们循环 k 次，i 的值将是 3^k。当 3^k 大于或等于 n 时，循环停止。

要找出循环执行了多少次，我们可以求解 3^k >= n，这意味着 k 大约是 log3(n)。因此，这个函数的时间复杂度是以3为底 n 的对数。

所以，正确答案是：

D. O(log3n)

![picture 5](../images/59927572c6997e032fa6dc08ff946b30614f9a983855c8fb74a70b62463bd68b.png)  

这段代码的工作方式是从 i=1 开始，每次循环 i 的值都翻倍，直到 i 大于 n。

这相当于每次循环都将问题的规模缩小一半。这种类型的循环通常具有对数时间复杂度。为了找到 i 等于或超过 n 需要循环多少次，我们解等式 2^k = n，其中 k 是循环的次数。解这个等式相当于求 n 的以2为底的对数，所以时间复杂度是 O(log2n)。

因此，正确答案是：

A. O(log2n)

![picture 6](../images/9ccb6c5245ddbfdb0fd3c244ae701644d4855fe465be536e0c0342d5b05b181b.png)  

在一个链队列中，`f`（通常表示front）是队首指针，指向队列的第一个元素，而`r`（通常表示rear）是队尾指针，指向队列的最后一个元素。在队列中，删除操作通常发生在队首，即移除队列中的第一个元素。

所以，如果要删除队列的一个节点（即队列的第一个节点或队首），我们需要将队首指针 `f` 移动到下一个节点。这是因为在队列中，元素是从队首移除的，而新元素是从队尾添加的。

因此，正确答案是：

C. f = f->next

这表示将队首指针 `f` 更新为指向当前队首节点的下一个节点，即移除了当前的队首节点。

![picture 7](../images/792a65e73f7442becc3a583ff4d17320390a1eba47ce48b798f60994798c545d.png)  

当列车顺序进入一个栈结构的站台时，列车的出站顺序会遵循后进先出（LIFO）的原则。这意味着一辆列车只有在进入站台后所有前面的列车已经离开时才能离开。我们可以根据这个原则来分析每个选项是否可能。

A. 1234
这是可能的，因为列车可以按照进站的顺序离开。

B. 1243
这也是可能的。列车1离开，列车2进入然后离开，接着列车3和4依次进入，列车4先离开，然后列车3离开。

C. 1324
这是不可能的。要想让列车3在列车2之前出站，列车2必须在列车3之后进站，或者列车2在没有出站的情况下，列车3进站并出站。但根据题目的进站顺序，列车2在列车3之前进站，因此列车3不可能在列车2之前出站。

D. 1423
这是可能的。列车1离开，然后列车2进入站台但停留在那里，列车4进入然后立即离开，随后列车3进入然后立即离开，最后列车2离开。

所以，不可能的出站顺序为：

C. 1324

![picture 8](../images/2961eb25a3e75a2a2602c6d4717f6995582c6aff7a5cc7577cf457abfca2a7cc.png)  

在分析算法的时间复杂度时，我们通常关注最高阶项，因为它决定了算法的增长速率。在这个函数中，`T(n) = 300n + 20n log n + 10n^2`，有三项：线性项、线性对数项和二次项。

在大 O 表示法中，我们关注的是当 n 趋向于无穷大时，哪一项的增长速率最高。在这个例子中，`10n^2` 是最高阶项，因为随着 n 的增长，它会比其他项增长得更快。

所以，这个函数的时间复杂度是：C. O(n^2)

![picture 10](../images/a65374d6ea7a5cf2a5c93a00d483302a5f0e45bd7e6659f8a16c0781e8f2e009.png)  

正确答案选A

>"长度为2的有序表"指的是一个包含两个元素的列表，这两个元素已经按照某种特定的顺序排列好了，这种顺序通常是按照从小到大或者从大到小的顺序。
>
>在归并排序的上下文中，"长度为2的有序表"通常表示在排序过程的某个阶段，你有多个包含两个元素的子序列，每个子序列内部的元素都是有序的，而这些子序列之间可能还没有完全排序。
>
>例如，如果你有一组数字 `[3, 1, 4, 2]`，按照归并排序的第一步，你会将它们分成两个子序列 `[3, 1]` 和 `[4, 2]`。在这里，每个子序列可以视为一个长度为2的未排序表。接下来，你会分别对这两个子序列进行排序，得到 `[1, 3]` 和 `[2, 4]`。现在，这两个子序列就变成了“长度为2的有序表”，因为它们内部各自都是有序的。然后在归并排序的下一步中，你会将这两个有序的子序列合并成一个完全有序的序列。

通过一趟归并排序后的正确结果是 `[16, 23, 25, 35, 40, 48, 79, 82]`。这个结果是通过将原始序列分成四对长度为2的有序子序列，然后将这些子序列归并排序得到的。在归并排序中，每一对有序子序列会合并为一个有序序列，然后这些更长的有序序列继续归并，直到得到一个完全排序的序列。

在提供的选项A、B、C和D中，没有任何一个选项与通过一趟归并排序后得到的结果完全匹配。这可能是因为题目的选项有误，或者题目意图测试对归并排序理解的错误。正确的归并排序过程是这样的：

1. 分割序列为四个子序列：(25, 48), (16, 35), (79, 82), (23, 40)。
2. 每个子序列已经是有序的，因为它们只有两个元素。
3. 进行一趟归并排序：
   - 归并 (25, 48) 和 (16, 35) 得到 (16, 25, 35, 48)
   - 归并 (79, 82) 和 (23, 40) 得到 (23, 40, 79, 82)
   - 最后，归并 (16, 25, 35, 48) 和 (23, 40, 79, 82) 得到最终排序结果。

因此，正确答案应该是一趟归并后的有序列表 `[16, 23, 25, 35, 40, 48, 79, 82]`。由于这不匹配任何给定的选项，正确答案可能不在提供的选项中。

--------------------------
- 对（25, 48, 16, 35, 79, 82, 23, 40）进行归并排序后的过程和结果是？

在对序列（25, 48, 16, 35, 79, 82, 23, 40）进行归并排序的过程中，每一步的变化如下：

1. 初始序列:
   `[25, 48, 16, 35, 79, 82, 23, 40]`

2. 分割序列并开始排序:
   - 分割前半部分: `[25, 48]`
   - 分割后半部分: `[16, 35]`

3. 合并排序结果:
   - 合并 `[25, 48]` 和 `[16, 35]` 得到 `[16, 25, 35, 48]`

4. 分割序列并开始排序:
   - 分割前半部分: `[79, 82]`
   - 分割后半部分: `[23, 40]`

5. 合并排序结果:
   - 合并 `[79, 82]` 和 `[23, 40]` 得到 `[23, 40, 79, 82]`

6. 最终合并两个有序子序列:
   - 合并 `[16, 25, 35, 48]` 和 `[23, 40, 79, 82]` 得到最终排序结果 `[16, 23, 25, 35, 40, 48, 79, 82]`

所以，归并排序的最终结果是一个有序序列 `[16, 23, 25, 35, 40, 48, 79, 82]`。在每一步中，都是将两个较小的有序列表合并成一个更大的有序列表，最终得到整个有序的序列。

- 为什么不分割前半部分: [25, 48, 16, 35]
分割后半部分: [79, 82, 23, 40]？

在归并排序算法中，分割的过程是将当前序列对半分割，直到每个子序列只包含一个元素或者两个元素，因为一个元素或者两个元素易于排序。这是一个递归的过程，目的是让合并的操作更加简单，因为合并两个已排序的序列比排序一个未排序的序列要简单得多。

在您提到的序列（25, 48, 16, 35, 79, 82, 23, 40）中，分割的第一步确实是将序列分为两个部分：前半部分 `[25, 48, 16, 35]` 和后半部分 `[79, 82, 23, 40]`。这是归并排序的第一步，也是递归分割开始的地方。

之后，这两个子序列 `[25, 48, 16, 35]` 和 `[79, 82, 23, 40]` 分别再次被分割。对于前半部分 `[25, 48, 16, 35]`，它会被分割成 `[25, 48]` 和 `[16, 35]`；对于后半部分 `[79, 82, 23, 40]`，它会被分割成 `[79, 82]` 和 `[23, 40]`。这样做是为了让每个子序列足够小，以至于可以很容易地对其进行排序。

在我的之前的解释中，我直接展示了这些分割后的小序列的合并过程，因为它们是排序和合并的基本单位。但实际上，在合并之前，确实是有一个完整的分割过程的，它将原始序列分解成越来越小的子序列，直到这些子序列可以容易地被排序和合并。

归并排序的关键步骤：
1. **分割**：将原始序列分割成更小的子序列，直到子序列的长度为1或2，这样它们自然就是有序的（单个元素自视为有序，两个元素可以简单地排序）。
2. **合并**：有序子序列可以被合并成一个有序序列。因为子序列是有序的，所以合并操作可以简单地从两个子序列的头部开始，选择两者中较小的元素放入新序列，直到所有元素都被合并。

如果你不按照这个过程去做，直接对 `[25, 48, 16, 35]` 和 `[79, 82, 23, 40]` 这样的未排序子序列进行合并，你就不能保证最终的结果是有序的。所以，归并排序的正确性依赖于递归地分割和合并过程，确保每次合并操作的两个输入子序列都是有序的。

简而言之，归并排序的精髓在于**分治法**的应用：先解决子问题（对小的子序列排序），然后将子问题的答案组合起来（合并有序的子序列），从而解决原问题（排序整个序列）。

- 不能对 [25, 48, 16, 35] 和 [79, 82, 23, 40] 这样的未排序子序列排序吗？

可以对 `[25, 48, 16, 35]` 和 `[79, 82, 23, 40]` 这样的子序列进行排序，但在归并排序的过程中，这种排序是通过递归地分割子序列直到它们变得足够小（最理想是一个或两个元素），然后通过合并已排序的子序列来完成的。这种方法允许算法以统一和高效的方式来处理排序问题。

如果你不通过递归分割，而是直接对这些子序列进行排序，那么你需要使用另一种排序算法（如插入排序、选择排序或快速排序等）来对这些子序列进行排序，然后再进行归并。这样做实际上是在归并排序外部引入了另一种排序逻辑。

归并排序的优势在于其合并步骤非常高效，因为它假定合并的两个子序列已经是有序的。如果合并未排序的序列，归并排序的优势就会丧失，因为合并操作依赖于子序列的有序性来确保整个序列的有序性。这也是为什么归并排序通常是通过递归进行分割直至每个子序列简单到可以直接视为有序，然后再将它们合并起来。
>举例：（若是[16, 51, 50, 49]这种则其内还没排序合并好，不可以和另外的序列合并，这种就不能为下面例，不合规矩）
>
>合并有序列表 `[16, 49, 50, 51]` 和 `[23, 40, 79, 82]` 得到最终排序结果的过程如下：
>
>1. 初始列表:
>   `[16, 49, 50, 51, 23, 40, 79, 82]`
>
>2. 合并过程:
>   - `[16]` (取 `16`，因为 16 < 23)
>   - `[16, 23]` (取 `23`，因为 23 < 49)
>   - `[16, 23, 40]` (取 `40`，因为 40 < 49)
>   - `[16, 23, 40, 49]` (取 `49`，因为 49 < 79)
>   - `[16, 23, 40, 49, 50]` (取 `50`，因为 50 < 79)
>   - `[16, 23, 40, 49, 50, 51]` (取 `51`，因为 51 < 79)
>   - `[16, 23, 40, 49, 50, 51, 79]` (取 `79`，因为没有更多的元素在第一个列表中)
>   - `[16, 23, 40, 49, 50, 51, 79, 82]` (最后添加 `82`)
>
>在每一步，我们比较两个列表的头部元素，并选择更小的那个加入到合并后的列表中。如果一个列表的所有元素都被选中，剩余的另一个列表中的所有元素将按顺序加入到合并后的列表中。
>
>3. 最终排序结果:
>   `[16, 23, 40, 49, 50, 51, 79, 82]`
>
>这个过程展示了归并排序的合并阶段，即如何将两个已排序的子列表合并成一个单一的、更大的、有序的列表。

![picture 11](../images/9b82e8196b171b8b46ea9324fc2b485112278403ec039c5bc5e33a32463e1fc2.png)  

在二分查找中，我们首先找到中间位置的元素。由于数组是从0开始计数的，所以10个元素的数组中间位置的索引是 `(0 + 9) / 2`，其中9是最后一个元素的索引。在整数除法中，这将给出 `4` 作为中间位置的索引。

因此，实际的第一个比较应该是数组中索引为4的元素，即 `20`。但由于我先前解释的错误，请允许我重新计算正确的比较序列。

给定的数组为 `{4, 6, 10, 12, 20, 30, 50, 70, 88, 100}`，我们需要找到58的二分查找比较序列。

1. 中间位置是 `(0 + 9) / 2 = 4`，比较的元素是 `20`。
2. `20` 小于 `58`，所以我们将在右半部分 `{30, 50, 70, 88, 100}` 继续查找。
3. 这个子数组的中间位置是 `(5 + 9) / 2 = 7`（数组的整体索引），比较的元素是 `70`。
4. `70` 大于 `58`，所以我们将在 `{30, 50}` 中继续查找。
5. 这个子数组的中间位置是 `(5 + 6) / 2 = 5`（数组的整体索引），比较的元素是 `30`。
6. `30` 小于 `58`，所以我们将在 `{50}` 中继续查找，这是数组中 `30` 和 `70` 之间的元素。
7. `50` 小于 `58`，而数组中没有其他元素，所以查找结束。

正确的比较序列是 `20, 70, 30, 50`，所以正确答案是 B. 20, 70, 30, 50。

>为什么这里十个元素的中间位置元素是第5个而不是第6个？这两个都在中间位置啊？
>
在二分查找算法中，选择中间位置元素时通常采用“下整”方法，即当中间位置不是整数时，会取较小的那个整数作为中间位置的索引。对于有10个元素的数组，中间位置的索引计算方法是：

$$
\text{中间索引} = \left\lfloor \frac{\text{起始索引} + \text{结束索引}}{2} \right\rfloor
$$

对于数组 {4, 6, 10, 12, 20, 30, 50, 70, 88, 100}，起始索引是0，结束索引是9（因为数组索引从0开始）。计算中间位置索引为：

$$
\text{中间索引} = \left\lfloor \frac{0 + 9}{2} \right\rfloor = \left\lfloor 4.5 \right\rfloor = 4
$$

因此，中间位置元素是数组中索引为4的元素，即第五个元素 `20`（因为我们从1开始计数元素，而索引是从0开始）。这就是为什么我们选取第五个元素作为中间值进行比较的原因。

根据二分查找的这个过程，我们会首先比较20，然后根据比较结果决定是检查左边还是右边的子数组，并重复这个过程。这样确保了算法的效率和正确性。

![picture 12](../images/0489dfb7fd6d60f387c76260eb1f7305a0fb97fdb173b2c1605a0de728698660.png)  

![picture 16](../images/debbc41b233bdd279ce7954d1594e7742cb12f0e0d49bede874ddab51a94ce28.png)  

![picture 17](../images/709cc9583ecfbf73f57e187a22d667c229c3b76057cf070b1335904a361e42a6.png)  

![picture 18](../images/4631ef285e3d35bcdec4a2cfc95b1f09e8e4a74fbbb581f2fe86f6f20a2a5efb.png)  

![picture 19](../images/bf0d9abe913df17a24dc71ff2801e48fbd17ceb3d5cac265352c4b1d21d4e555.png)  

![picture 20](../images/ccec59fecd04db91257d88f07b712e7ac817e80a08afd6fd3c1f90723d3544de.png)  

![picture 21](../images/a052840f8cb1cd733ef3feb38eacb9e725c6e3f069d99eedea72cb731debbeb0.png)  

![picture 23](../images/bbe8a1ad8575d96214676ad14810de82efb39e4b40213cf7e56ee81c464357f7.png)  

![picture 22](../images/1d11b58b68743d2d23041459a1cfb34148c33e8d49030c641072555f573c7c94.png)  

![picture 24](../images/a82800d5bdf4aab07099b70cfcb17532dc2c6cf375310307c645d32c81033354.png)  

![picture 25](../images/b4cf6b162acd9c1250f6ffdb2e37584218a999f7d878d2c574ca746087795b2b.png)  

![picture 26](../images/f653b180a4cfe0779834b2c587603b35c68a1df01df5e9a8becef08f92f2e93f.png)  

![picture 27](../images/8f7242f81d296cdd464565ac459b8f5f798c6e047c7a742443e3eca926f3a0c0.png)  

![picture 28](../images/86d594506337fb29ba4795f8480c7f3d83569b7fcf7738a4751e13fb15c462bc.png)  

![picture 29](../images/98aaa24704fb1a7fcbe507eae255f0eaeb7acca8863f697da9071b32cc93fd45.png)  

![picture 31](../images/8206fe60b666df0977f5af5208a4073c5676398dea904911ee59e98d5a786f3c.png)  

![picture 32](../images/4b1408e673b9f2b4f5c20f1f7486fcdcf54b6304cf2dde4fb5d327022732dbb9.png)  

![picture 33](../images/a4acab2fcb115533ed289a2fac6fcce0ccc2216f4bd80b24d57b37562891d7e3.png)  

![picture 35](../images/c23ac90bee534aeb52e785306001730e0051aa14ceb85c176c08f9a60296c879.png)  

![picture 36](../images/3c9394a56132c85405218ea48a2557a6b1e3997b72edbefd6a4ba83aa07fe019.png)  

# 填空

1. 数据结构包括数据的<u>逻辑结构</u>、数据的<u>存储结构</u>、和数据的运算这三个面的内容。
2. 向一个长度为n的线性表的第i个元素(1<=i<=n+1)之前插入一个元素时，需向后移动<u>n-i+1</u>个元素。
3. 顺序表中逻辑上相邻的元素物理位置<u>必定</u>相邻，单链表中逻辑上相邻的元素物理位置<u>不一定</u>相邻。

# 大题

# 考点

## 数据结构的含义和分类

数据结构是计算机科学中的一个重要概念，它是关于如何组织和存储数据的方法和技术。数据结构的目的是为了使数据的存储更高效，并使对数据的访问和修改操作更加方便和快速。数据结构的选择和设计对程序的性能有重要影响。

数据结构通常分为两大类：

### 1. 线性数据结构
这类数据结构中的元素以线性的方式排列，每个元素最多有一个前驱和一个后继。常见的线性数据结构包括：
   - **数组**：将元素存储在连续的内存位置中。
   - **链表**：包括单链表、双向链表、循环链表等，元素分散存储，通过指针相互连接。
   - **栈**：一种后进先出（LIFO）的数据结构。
   - **队列**：一种先进先出（FIFO）的数据结构。

### 2. 非线性数据结构
这类数据结构中的元素不是简单的线性排列，而是可以有多个关系。常见的非线性数据结构包括：
   - **树**：如二叉树、平衡树（如AVL树）、堆等，具有分支的层次结构。
   - **图**：由节点（顶点）和边组成，可以表示复杂的关系，如网络、路径等。

除此之外，还有一些更复杂的数据结构，如哈希表、堆积树（Trie）、B树、红黑树等，它们在特定的应用场景下提供了高效的数据存储和访问方法。

数据结构的选择依赖于数据的类型、大小、以及要执行的操作类型（如添加、删除、搜索、排序等）。一个好的数据结构可以提高数据处理的效率和性能。

数据结构除了按照线性和非线性分类之外，还可以根据不同的标准或视角进行分类。以下是一些常见的分类方式：

### 1. 按存储结构分类
- **顺序存储结构**：数据元素存放在地址连续的存储单元里，如数组。
- **链式存储结构**：数据元素存放在任意的存储单元里，这些存储单元可以是连续的也可以是非连续的，如各种链表。

### 2. 按数据的可变性分类
- **静态数据结构**：一旦创建就不能改变其结构，例如数组。
- **动态数据结构**：可以在运行时动态地改变其结构，例如链表、树、图等。

### 3. 按抽象数据类型分类
- **简单数据结构**：基本数据类型，如整型、浮点型、字符型等。
- **复合数据结构**：由基本数据类型组合而成，如结构体、类。

### 4. 按操作特性分类
- **线性数据结构**：如数组、链表、栈、队列。
- **树形数据结构**：如二叉树、AVL树、B树。
- **图形数据结构**：如无向图、有向图。

### 5. 按应用领域分类
- **集合结构**：元素之间除了“属于同一个集合”外没有其他关系。
- **线性结构**：元素之间一对一的关系。
- **树结构**：元素之间一对多的关系。
- **图结构**：元素之间多对多的关系。

### 6. 按数据处理方式分类
- **输入/输出数据结构**：如文件、缓冲区。
- **存储数据结构**：用于内部存储和组织数据，如链表、树、图等。

每种分类方法都有其独特的视角，用于解决特定类型的问题或满足特定的应用需求。理解这些不同的分类和数据结构的特点，可以帮助选择最适合特定问题的数据结构。

## 单链表和顺序表

在数据结构中，单链表和顺序表是两种不同的数据存储结构，它们用于组织和管理数据。这两种结构有各自的特点和用途：

### 单链表（Singly Linked List）
1. **定义**：单链表是一种线性数据结构，由一系列节点（Node）组成。每个节点包含两部分：一部分存储数据元素，另一部分存储指向下一个节点的指针。
2. **特点**：
   - **动态大小**：链表的大小可以动态变化，不需要预先定义大小。
   - **非连续存储**：节点不需要在内存中连续存储，它们通过指针连接。
   - **插入和删除效率高**：在链表中插入或删除元素不需要移动其他元素，只需修改指针即可。
   - **内存利用率高**：只分配所需的内存，没有空间浪费。
   - **访问效率较低**：访问链表中的元素需要从头节点开始逐个遍历。

### 顺序表（Sequential List）
1. **定义**：顺序表是一种线性数据结构，它将元素顺序存储在一块连续的内存空间中。在大多数情况下，顺序表通过数组实现。
2. **特点**：
   - **固定大小**：顺序表的大小通常在初始化时定义，虽然也有动态数组的实现。
   - **连续存储**：所有元素在内存中连续存放。
   - **随机访问**：可以直接通过索引快速访问任何元素，访问效率高。
   - **插入和删除效率低**：插入或删除元素可能需要移动大量元素来维持元素的连续性。
   - **可能有空间浪费**：如果预先分配的空间没有完全使用，会有空间浪费。

### 总结
- **单链表**适合于经常进行插入和删除操作的场景，特别是在不知道数据量大小的情况下。
- **顺序表**则适用于经常进行随机访问的应用场景，但插入和删除操作效率较低。

## 线性表

线性表呢？是上述俩个的统称？

是的，线性表是一个更广泛的术语，它包括顺序表和单链表。线性表是一种数据结构，用于存储具有相同特性的数据元素。在线性表中，数据元素之间是一对一的关系。这意味着除了第一个和最后一个元素之外，每个元素都有一个前驱和一个后继。

线性表可以有两种主要的物理结构：

1. **顺序存储结构**：也就是顺序表。在这种结构中，表中的元素存储在连续的存储空间内，元素之间的逻辑顺序和物理顺序相同。

2. **链式存储结构**：包括单链表、双链表、循环链表等。在这种结构中，表中的元素分散存储在内存中，元素之间通过指针连接。

因此，线性表是一个总称，它根据存储结构的不同可以分为<u>顺序表和链表（包括单链表）</u>。线性表的选择取决于具体的应用需求，如对存储空间的效率、数据访问速度、数据插入和删除操作的频繁程度等。

## 有序表和顺序表有什么区别？

有序表和顺序表是两种不同的数据结构概念，它们的主要区别在于元素的排列方式和存储方式：

### 有序表（Ordered List）
- **排列方式**：在有序表中，元素按照某种特定的顺序（如数值顺序、字母顺序等）存储。这意味着表中的元素是根据它们的键值（或某些属性）来排序的。
- **查找效率**：由于元素是有序的，有序表可以使用高效的查找算法，如二分查找，提高查找效率。
- **插入和删除操作**：插入和删除操作可能需要移动元素以保持元素的顺序，这在某些实现中可能是成本较高的操作。
- **实现方式**：可以基于不同的内部结构实现，如数组或链表。

### 顺序表（Sequential List）
- **存储方式**：顺序表是指元素在物理存储上按顺序连续存放的数据结构，通常是基于数组实现的。
- **排列方式**：在顺序表中，元素的排列并不一定是有序的。元素的顺序是根据它们加入表时的顺序，或者在内存中的物理位置。
- **访问效率**：由于是连续存储，顺序表支持快速的随机访问。
- **插入和删除操作**：插入和删除操作可能需要移动一些元素以维持元素的连续性，这在数组基础的顺序表中特别明显。

### 总结
- **有序表**的关键特点在于元素的**有序性**，不论其内部如何实现（数组或链表）。
- **顺序表**的核心在于元素的**连续存储**，通常基于数组实现，但元素不一定非得是有序的。

在具体应用中，选择哪种结构取决于对元素访问、插入和删除操作的性能要求。例如，如果需要频繁的查找操作，有序表可能更合适；如果需要频繁的随机访问，顺序表可能更优。

## 归并排序的方法

归并排序（Merge Sort）是一种高效的排序算法，采用分而治之的方法将问题分解为易于解决的子问题。其基本步骤如下：

1. **分割**：递归地将当前序列平均分割成两半。
2. **征服**：递归地对两半序列进行归并排序。
3. **合并**：将两个有序的子序列合并成一个有序序列。

下面是归并排序的详细步骤：

### 递归版本的归并排序

1. **递归分割**：
   - 如果序列的长度大于1，则可以分割。
   - 将序列分为两个子序列，每个子序列包含一半的元素。
   - 对这两个子序列递归进行归并排序。

2. **合并操作**：
   - 当子序列排序完成后，执行合并操作。
   - 创建一个临时数组，用于存放合并后的有序序列。
   - 比较两个子序列的前端元素，将较小的元素移动到临时数组中。
   - 重复此过程直到所有元素都被移动到临时数组中。
   - 将临时数组中的元素复制回原始序列，此时这部分序列是有序的。

### 非递归版本的归并排序（自底向上）

1. **初始归并**：
   - 将序列视为n个已经排序的子序列，每个子序列的长度为1。
   - 相邻子序列成对归并，生成n/2个长度为2的有序子序列。

2. **迭代合并**：
   - 增加子序列的长度，每次迭代翻倍，从2到4，再到8，一直到子序列长度大于或等于整个序列的长度。
   - 在每一轮迭代中，再次将相邻的有序子序列归并成更长的有序子序列。

归并排序的时间复杂度为 O(n log n)，其中n是序列中的元素数量。这种效率相比于简单排序算法（如冒泡排序、插入排序等）要好得多，尤其是在元素数量较大的时候。尽管归并排序需要额外的内存空间来存储临时数组，但它的稳定性和效率使其成为排序大型数据集的好选择。

>我用一个简单的例子来解释归并排序：
>
>想象一下你有一堆乱序的漫画书，你想把它们按照顺序排列起来。归并排序的策略就像是这样：
>
>1. **分割**：首先，你把漫画书分成两堆。如果这两堆还是太大，就继续分，直到每堆只有一个书或者一本书都没有。
>
>2. **排序**：然后，你开始比较每两堆里最上面的漫画书。你拿出较早的那本，把它放到一边。
>
>3. **合并**：你继续这样比较和拿出书，直到其中一堆空了。然后你把另一堆剩下的书全部放到排序好的漫画书堆上。
>
>4. **重复**：接着，你回到更大的两堆书，重复这个比较和合并的过程。每次合并，你都是在把两堆已经排好序的书合并成一堆更大的排好序的书堆。
>
>5. **完成**：最后，你会得到一堆排好序的漫画书，从最早的到最新的。
>
>归并排序的关键就在于这个“合并”过程。你每次都是在合并两个已经排好序的小堆书，这样比起从头开始排序来要简单得多。而且无论多少书，你都只是重复这个“分割、排序、合并”的过程，直到整个堆都排好了序。这就是归并排序的魔力所在！